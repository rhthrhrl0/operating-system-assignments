# operating-system-assignments
운영체제 수업 과목 과제 코드 및 보고서 정리

# 과제1. xv6 설치

과제 1번은 비교적 간단한 helloworld라는 쉘 프로그램을 만들고,
init.c 라는 xv6 초기 부팅 동작 코드 파일을 수정해서, os가 쉘을 띄우기 전에 로그인 과정을 추가함.

# 과제2. PCB 구조체 수정해서 trace 시스템 콜 만들기

과제 2번은 xv6 os의 PCB 블록인 proc 구조체에 int mask 필드를 추가해서, trace 시스템콜로 
이 mask 값을 조정할 수 있고, syscall.c에 있는 syscall 함수에서 실행한 시스템 콜 함수들의 수행완료 이후
이 프로세스가 trace 시스템 콜로 등록한 시스템 콜이였다면,그 시스템 콜의 이름과 반환값을 화면에 출력시키는 것입니다.

또한, 이 프로세스가 생성한 자식 프로세스 또한 부모 프로세스의 mask값을 물려받아야 하므로, proc.c의 fork함수를 
일부 수정했습니다.

이 외에도 xv6의 malloc 과 morecore 를 분석해서 xv6 운영체제의 메모리 페이지 할당 최소 단위가 
4096 바이트(즉,4KB)이라는 것을 알아냈습니다.

### 학습한 것
1. 시스템 콜을 직접 추가하기 위해, 시스템 콜의 호출 과정과 인터럽트 및 트랩에 대해 학습함.
   1. 트랩이 실행되는 과정에서 매크로를 통해 eax 레지스터의 값이 수정되는 코드를 확인함.
2. trace 시스템 콜을 만들기 위해, proc 구조체에 int mask 변수를 추가함.
   1. fork 함수에서 자식 프로세스에게 mask값을 물려받도록 하는 코드 추가
   2. syscall.c의 syscall 함수가 처리되는 과정에서 시스템 콜 실행 이후 해당 프로세스의 mask값을 확인해서 시스템 콜 이름과 반환값 출력하는 로직 추가
3. malloc 의 할당 과정 분석 및 새로운 메모리 페이지 할당시 4KB 단위로 할당하는 것을 확인함.

# 과제3. ssu_schedule 스케줄러를 직접 만들고 os에 적용해보기

ssu_schedule는 기존의 xv6 스케줄러가 순차적으로 기회를 할당하던 것과 달리 새롭게 생성되거나 wakeup으로 깨어난 프로세스에게
우선순위를 주는 스케줄러다. 

우선, 원리는 다음과 같다. 각 프로세스마다 priority와 weight값을 갖도록 proc 구조체를 수정한다.
이후, 전역 변수로 weight변수를 1로 설정하고, 실행되는 프로세스마다 weight값을 1씩 증가시키며 할당한다. 
그리고 한 프로세스가 수행을 마무리하고 다음 스케줄링 과정에 들어가기 전에 모든 프로세스에 대해 다음과 같은 공식을 적용시켜서 우선순위
업데이트를 한다.

new_priority = old_priority + (time_slice / weight) 

그리고, 모든 프로세스들을 관리하는 ptable 구조체에서는 min_priority 값을 유지하고 관리하며, 이는 현재 RUNNABLE 프로세스들 중
가장 우선순위가 작은 값을 말한다. 
새로 생긴 프로세스나 wakeup된 프로세스는 ptable의 min_priority를 초기 priority로 할당받는다.

또한, 이 스케줄러가 잘 동작하는지 확인하기 위해 Makefile 에서 CPU 코어 수를 한 개만 사용하도록 수정해야하며, 
sdebug 라는 쉘 프로그램을 사용해서 이 스케줄러가 잘동작하는지 확인할 수 있도록 프로세스 5개를 만들고 실행시켜서 
로그 프린트를 출력해야한다.

마지막으로, xv6가 디버그 모드로 실행된 경우는 ssu_schedule 에서 스케줄링 과정마다 매번 해당 프로세스 정보를 출력 해야한다.

### 학습한 것
1. 프로세스의 스케줄링 과정
   1. 프로세스의 상태가 언제 변하게 되는지를 실제 운영체제 코드로 확인할 수 있었음.
   2. 프로세스가 SLEEPING -> RUNNABLE 이 되는 wakeup 과정에 개입해서 코드를 조작하고 우선순위를 수정함.
   3. 우선순위를 할당하기 위해 proc 구조체에 priority 변수와 weight 변수를 추가함.
   4. ptable에서 RUNNABLE 상태의 가장 작은 프로세스의 우선순위를 유지하도록 함.
   5. 프로세스의 생성 fork 과정에 개입해서 해당 프로세스의 priority 초기값과 weight 값 할당 로직 추가
2. Makefile로 CPU 코어 수를 조절하는 방법

# 과제4. 페이지 교체 알고리즘 구현 

Optimal, FIFO, LIFO, LRU, LFU (Least Frequently Used), SC (Second Chance / One handed Clock) 참조(Reference, Read) Bit 하나 사용, ESC 
의 동작 방식을 따라 알고리즘들을 직접 구현해봄.

# 과제5. 기존의 파일시스템보다 저장공간을 효율적으로, 더 큰 파일을 저장할 수 있는 파일시스템 만들기

기존의 xv6의 inode 구조체는 12개의 직접블록과 1개의 간접블록을 사용한다.
한개의 데이터 블록 크기는 512Byte이므로 총 12개 + 128개(512/4) = 140개의 데이터 블록에 파일의 정보를 저장한다.
때문에 원래는 최대 70KB 크기의 파일밖에 저장하지 못하지만, 이번에 우리가 만들어볼 파일 시스템은 통칭 CS(Continuous Sector)파일시스템 이라고 불린다.
이 CS 파일 시스템은 inode의 직접 블록만 사용하며, inode 직접블록의 저장공간 4바이트 중 3바이트는 데이터블록의 시작 지점을, 1바이트는 시작 지점부터 연속된
공간의 갯수를 저장한다. 이를 통해 한개의 직접블록에서 여러 개의 데이터 블록을 가리킬 수 있도록 만드는 것임.

즉, 다시 한 번 정리하면, 연속된 섹터들이 inode에서 하나의 direct block이 가리킬 수 있도록 새로운 파일 시스템을 만드는 것이다
또한, 여기서 오해하면 안되는 것은 기존의 파일시스템과 새로운 파일 시스템을 두 가지 모두 동시 운영해야 한다.

** 다만, 이 파일 시스템은 수정과 관련된 것은 고려하지 않으며, 파일 생성과 삭제만 가능하다.
이 과제는 새로운 파일 시스템을 구축하고 그 과정에서 inode블록과 데이터 블록에 대한 접근 및 제어를 중점으로 학습하는 것에 의의를 둔다.

이 파일 시스템 구축을 위해, xv6의 stat.h에 T_CS 타입을 정의하고, 
CS 기반 파일을 생성하기 위해 fcntl.h에 플래그 (O_CS)를 추가한다. 이를 통해, create 시스템 콜로 파일을 생성할 때 파일 타입을 지정해서 생성할 수 있도록 함.

### 학습한 것
1. inode의 직접 블록과 간접 블록에 대해 학습하고, 저장되는 과정을 이해
   1. 이 과정에서 데이터 비트맵을 따라 비어있는 데이터블록을 할당받고 데이터를 쓰는 과정을 학습
   2. 파일시스템의 inode에 대해 인메모리 버퍼 내용을 디스크에 반영(커밋)하는 iupdate 함수에 대한 이해
   3. balloc과 ialloc에 대한 이해
   4. readi, writei 및 xv6의 버퍼캐시 및 디스크 간의 관계에 대한 이해
